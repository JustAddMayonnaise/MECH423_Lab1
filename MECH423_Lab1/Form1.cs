using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Media;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace SerialReaderSuperSimple
{
    public partial class frmMainWindow : Form
    {
        ConcurrentQueue<byte[]> outputDataQueue = new ConcurrentQueue<byte[]>();   // Concurrent queue for reading data stream from serial port
        List<int> xAxisList = new List<int>();                                     // List to store data points for calculating average (statistics)
        List<int> yAxisList = new List<int>();                                     // List to store data points for calculating average (statistics)
        List<int> zAxisList = new List<int>();                                     // List to store data points for calculating average (statistics)
        byte[] readBytes;                                                          // Byte array used to store for enqueue
        byte[] removedItemInDataQueue;                                             // Byte array used to store for dequeue
        int MAX_AVERAGE_N = 500;                                                   // Maximum amount of data points used for determining the average
        int MAX_GRAPH_DATAPOINTS = 100;                                            // Maximum amount of data points stored in graph
        int graphDatapointCount = 0;                                               // Variable to store the number of current data points
        int GRAVITY_CALIBRATION_NUM = 30;                                          // Threshold for determining the orientation (gravity)
        Stopwatch triggerStopwatch = new Stopwatch();                              // This stopwatch is used to filter the gesture for the Clefairy mini-game
        Stopwatch sequenceStopwatch = new Stopwatch();                             // This stopwatch is used to filter the gesture for the state machine
        int COMPLETED_GESTURE_TIMEOUT = 1000;                                      // Timeout limit for completed gestures before resetting
        int MULTISTAGE_GESTURE_TIMEOUT = 1000;                                     // Timeout limit for progressing multistage gestures before resetting
        int TIME_BEFORE_NEXT_GESTURE = 500;                                        // Time before allowing reading of the next gesture for multistage gestures
        double xAxisVariance = 0;
        double yAxisVariance = 0;
        double zAxisVariance = 0;

        ConcurrentQueue<int> bytesToReadQueue = new ConcurrentQueue<int>();        // Concurrent queue for reading amount of bytes to read from serial port
        int removedBytesToRead;                                                    // Variable to store the number of bytes to read from serial port to form
        int byteSequence = 0;                                                      // Variable to store the byte sequence to read from the data stream

        int GESTURE_THRESHOLD_UPPER = 184;                                         // Upper threshold for determining if a gesture has been made (184-254, diff = 70)
        int GESTURE_THRESHOLD_LOWER = 70;                                          // Lower threshold for determining if a gesture has been made (0-70, diff = 70)
        int gestureState = 0;                                                      // Variable to store state for the gesture sequence state machine

        List<int> sequenceGenerated = new List<int>();                             // List to store the sequence generated by computer for the Clefairy mini-game
        List<int> sequenceAIP2 = new List<int>();                                  // List to store the sequence generated by the AI (random generator)
        List<int> sequenceAIP3 = new List<int>();                                  // List to store the sequence generated by the AI (random generator)
        List<int> sequenceAIP4 = new List<int>();                                  // List to store the sequence generated by the AI (random generator)
        List<int> sequenceInputted = new List<int>();                              // List to store the sequence inputted by player for the Clefairy mini-game
        int MAX_SEQUENCE = 12;                                                     // Set maximum sequence to generate for Clefairy game
        int currentSequence;                                                       // Variable to store the sequence generated index for Clefairy game
        int readGestureSequence;                                                   // Variable to store the sequence read from accelerometer index for Clefairy game
        int MAX_PROGRESS_BAR_TIME = 700;                                           // Max time the player is allocated to record gestures for the Clefairy mini-game
        int progressBarTime;                                                       // Variable to store how much time has elapsed to for the progress bar used in Clefairy mini-game
        bool readGestures = false;                                                 // Bool variable to set whether to play the Clefairy mini-game
        int maxReadGestures;                                                       // Variable to store the number of gestures read for Clefairy mini-game

        int xAccelRaw;                                                             // Variable to store the raw x accel value from serial port
        int yAccelRaw;                                                             // Variable to store the raw y accel value from serial port
        int zAccelRaw;                                                             // Variable to store the raw z accel value from serial port

        SoundPlayer clefairyDancing = new SoundPlayer(@"C:\Users\davidwong\Desktop\Clefairy Pictures\Clefairy_Dancing_Sound.wav");
        SoundPlayer clefairySaysClassStarting = new SoundPlayer(@"C:\Users\davidwong\Desktop\Clefairy Pictures\Clefairy_Class_Starting.wav");
        SoundPlayer clefairyDancingSequence = new SoundPlayer(@"C:\Users\davidwong\Desktop\Clefairy Pictures\Clefairy_Dancing_Sequence.wav");
        SoundPlayer clefairyPressButton = new SoundPlayer(@"C:\Users\davidwong\Desktop\Clefairy Pictures\Clefairy_Press_Button.wav");
        SoundPlayer clefairyBackground = new SoundPlayer(@"C:\Users\davidwong\Desktop\Clefairy Pictures\Clefairy_Background.wav");
        SoundPlayer clefairyWins = new SoundPlayer(@"C:\Users\davidwong\Desktop\Clefairy Pictures\Clefairy_Wins.wav");
        bool clefairyBackgroundIsPlaying = false;
        Stopwatch clefairyPressButtonTimeAfter = new Stopwatch();                 // This stop watch is used to wait until clefairy finishes talking
        Stopwatch displayInstructionTime = new Stopwatch();                       // This stop watch is used to synchronize Clefairy instructions
        bool isGamePlaying = false;                                               // Flag to make sure the game does not reset
        int scoreP1 = 0;                                                          // Variable to keep track of player 1's score
        int scoreP2 = 0;                                                          // Variable to keep track of player 2's score
        int scoreP3 = 0;                                                          // Variable to keep track of player 3's score
        int scoreP4 = 0;                                                          // Variable to keep track of player 4's score
        int mistakesP1 = 0;                                                       // Variable to keep track of player 1's mistakes
        int mistakesP2 = 0;                                                       // Variable to keep track of player 2's mistakes
        int mistakesP3 = 0;                                                       // Variable to keep track of player 3's mistakes
        int mistakesP4 = 0;                                                       // Variable to keep track of player 4's mistakes
        List<int> calculateScore = new List<int>();                               // Variable array to determine score
        FileStream fileStreamForCSV;                                              // Used for creating the file to write to
        SaveFileDialog saveToCSV = new SaveFileDialog();                          // Save dialog to create the file to write to
        bool writeToCSV = false;                                                  // Flag to allow writing to csv

        public frmMainWindow()
        {
            InitializeComponent();
            readBytes = new byte[serCOM.ReadBufferSize];
            serCOM.BaudRate = 9600;
            serCOM.DataBits = 8;
            serCOM.StopBits = System.IO.Ports.StopBits.One;
            serCOM.Parity = System.IO.Ports.Parity.None;

            pgrsReadInput.Maximum = MAX_PROGRESS_BAR_TIME;
            pgrsReadInput.Value = 0;
            pgrsReadInput.Step = 1;
        }

        // This is responsible for showing the COM ports and refreshing them when the drop down menu is clicked
        private void cmbbxCOMPorts_DropDown(object sender, EventArgs e)
        {
            string[] COMPortNames = System.IO.Ports.SerialPort.GetPortNames().ToArray();
            cmbbxCOMPorts.Items.Clear();
            for (int cntr = 0; cntr < COMPortNames.Length; cntr++)
                cmbbxCOMPorts.Items.Add(COMPortNames[cntr]);
        }
        
        // This is responsible for clicking on the button for connecting/disconnecting
        private void btnConnectDisconnect_Click(object sender, EventArgs e)
        {
            if(serCOM.IsOpen)
            {
                lock (serCOM) serCOM.Close();             // Mutex on the serial port
                btnConnectDisconnect.Text = "Connect";    // Changes button text to 'connect'
                lstbxSerParam.Items.Clear();              //
                cmbbxCOMPorts.Enabled = true;             // Enables clicking on the combo box for COM ports
                tmrSerRead.Enabled = false;               // Disables the timer for reading concurrent queue from serial port

                while (outputDataQueue.TryDequeue(out removedItemInDataQueue)) { }      // Clears buffer in queue
                foreach (var series in chrtAccelData.Series)                            // Clears the chart
                {
                    series.Points.Clear();
                }
                graphDatapointCount = 0;

                xAxisList.Clear();                        // Clears the list used for average (statistics)
                yAxisList.Clear();                        // Clears the list used for average (statistics)
                zAxisList.Clear();                        // Clears the list used for average (statistics)

                txtXAxis.Clear();                         // Clears txtXAxis box
                txtYAxis.Clear();                         // Clears txtYAxis box
                txtZAxis.Clear();                         // Clears txtZAxis box
                txtbxOrientation.Clear();                 // Clears orientation text box
                txtbxBytesInQueue.Clear();                // Clears bytes in queue text box
                txtbxBytesToRead.Clear();                 // Clears bytes to read text box
                txtbxGestureSequence.Clear();             // Clears gesture sequence text box
                txtXAvg.Clear();                          // Clears average (statistics) text box
                txtYAvg.Clear();                          // Clears average (statistics) text box
                txtZAvg.Clear();                          // Clears average (statistics) text box
            }
            else
            {
                if(!string.IsNullOrWhiteSpace(cmbbxCOMPorts.Text))
                {
                    try
                    {
                        lock(serCOM)
                        {
                            serCOM.PortName = cmbbxCOMPorts.Text;
                            serCOM.Open();
                            btnConnectDisconnect.Text = "Disconnect";
                            lstbxSerParam.Items.Add("Baud Rate: " + serCOM.BaudRate.ToString());
                            lstbxSerParam.Items.Add("Data Bits: " + serCOM.DataBits.ToString());
                            lstbxSerParam.Items.Add("Stop bit: " + serCOM.StopBits.ToString());
                            lstbxSerParam.Items.Add("Parity: " + serCOM.Parity.ToString());
                            lstbxSerParam.Items.Add("Read Buffer Size: " + serCOM.ReadBufferSize.ToString());
                            lstbxSerParam.Items.Add("Received Bytes Threshold: " + serCOM.ReceivedBytesThreshold.ToString());
                            cmbbxCOMPorts.Enabled = false;
                            tmrSerRead.Enabled = true;
                        }
                    }
                    catch (Exception myException)
                    {
                        MessageBox.Show(myException.Message);
                    }
                    
                }
                else
                {
                    MessageBox.Show("No COM port selected. Please try again.", "ERROR");
                }

            }
        }

        // This timer is responsible for reading from the concurrent queue. As well, it will read from concurrent queue for the Clefairy mini-game
        private void tmrSerRead_Tick(object sender, EventArgs e)
        {
            txtbxBytesInQueue.Text = Convert.ToString(outputDataQueue.Count());
            while (outputDataQueue.Count() > 1)                                       // While statement to ensure we read the latest data from queue
            {
                outputDataQueue.TryDequeue(out removedItemInDataQueue);
            }
            
            if (outputDataQueue.TryDequeue(out removedItemInDataQueue))               // If statement to see if data can be read from the queue
            {                                                                         
                if (bytesToReadQueue.TryDequeue(out removedBytesToRead))              // If statement to see how many bytes to read
                    txtbxBytesToRead.Text = Convert.ToString(removedBytesToRead);     // Display how many bytes to read to the form
                                                                                      
                xAccelRaw = Convert.ToInt16(removedItemInDataQueue[0]);               // Converts x acceleration from byte to int
                yAccelRaw = Convert.ToInt16(removedItemInDataQueue[1]);               // Converts y acceleration from byte to int
                zAccelRaw = Convert.ToInt16(removedItemInDataQueue[2]);               // Converts z acceleration from byte to int
                                                                                      
                txtXAxis.Text = Convert.ToString(xAccelRaw);                          // Displays raw x accleration to the form
                txtYAxis.Text = Convert.ToString(yAccelRaw);                          // Displays raw y accleration to the form
                txtZAxis.Text = Convert.ToString(zAccelRaw);                          // Displays raw z accleration to the form

                // Code to write data to a csv file
                if(writeToCSV)
                {
                    using (StreamWriter sw = File.AppendText(txtbxFileName.Text))
                    {
                        sw.WriteLine(Convert.ToString(xAccelRaw) + "," + Convert.ToString(yAccelRaw) + "," + Convert.ToString(zAccelRaw));
                    }
                }

                int xAccel = xAccelRaw - 128;                                         // Calibrate x acceleration (used to determine orientation)
                int yAccel = yAccelRaw - 128;                                         // Calibrate y acceleration (used to determine orientation)
                int zAccel = zAccelRaw - 128;                                         // Calibrate z acceleration (used to determine orientation)

                if (xAccel < -GRAVITY_CALIBRATION_NUM) txtbxOrientation.Text = "X";          // Display orientation to text box
                else if (xAccel > GRAVITY_CALIBRATION_NUM) txtbxOrientation.Text = "-X";     // Display orientation to text box
                else if (yAccel < -GRAVITY_CALIBRATION_NUM) txtbxOrientation.Text = "Y";     // Display orientation to text box
                else if (yAccel > GRAVITY_CALIBRATION_NUM) txtbxOrientation.Text = "-Y";     // Display orientation to text box
                else if (zAccel < -GRAVITY_CALIBRATION_NUM) txtbxOrientation.Text = "-Z";    // Display orientation to text box
                else if (zAccel > GRAVITY_CALIBRATION_NUM) txtbxOrientation.Text = "Z";      // Display orientation to text box
                else txtbxOrientation.Clear();                                               // Display orientation to text box

                if (graphDatapointCount >= MAX_GRAPH_DATAPOINTS)                             // If there is too many points in the graph, delete some
                {                                                                            
                    chrtAccelData.Series["XAxisData"].Points.RemoveAt(0);                    // Delete first data point in x
                    chrtAccelData.Series["YAxisData"].Points.RemoveAt(0);                    // Delete first data point in y
                    chrtAccelData.Series["ZAxisData"].Points.RemoveAt(0);                    // Delete first data point in z
                    graphDatapointCount--;                                                   // Decrement counter
                }

                chrtAccelData.Series["XAxisData"].Points.AddY(xAccelRaw);                    // Add data point to x
                chrtAccelData.Series["YAxisData"].Points.AddY(yAccelRaw);                    // Add data point to y
                chrtAccelData.Series["ZAxisData"].Points.AddY(zAccelRaw);                    // Add data point to z
                graphDatapointCount++;                                                       // Increment counter

                /********************************************* START OF ALGORITHM FOR STATISTICS ON DATA *********************************************/
                xAxisList.Add(xAccelRaw);
                yAxisList.Add(yAccelRaw);
                zAxisList.Add(zAccelRaw);

                if (xAxisList.Count > MAX_AVERAGE_N)
                {
                    xAxisList.RemoveAt(0);
                    yAxisList.RemoveAt(0);
                    zAxisList.RemoveAt(0);
                }

                xAxisVariance = 0;
                yAxisVariance = 0;
                zAxisVariance = 0;

                for (int i = 0; i < xAxisList.Count; i++)
                {
                    xAxisVariance += Math.Pow((xAxisList.ElementAt(i) - xAxisList.Average()), 2);
                    yAxisVariance += Math.Pow((yAxisList.ElementAt(i) - yAxisList.Average()), 2);
                    zAxisVariance += Math.Pow((zAxisList.ElementAt(i) - zAxisList.Average()), 2);
                }
                
                txtXAvg.Text = Convert.ToString(Math.Sqrt(xAxisVariance / xAxisList.Count));
                txtYAvg.Text = Convert.ToString(Math.Sqrt(yAxisVariance / yAxisList.Count));
                txtZAvg.Text = Convert.ToString(Math.Sqrt(zAxisVariance / zAxisList.Count));
                /********************************************* END OF ALGORITHM FOR STATISTICS ON DATA *********************************************/

                /********************************************* START OF IF STATEMENT FOR STATE MACHINE *********************************************/
                if (gestureState == 0)                                                   // Beginning of state machine, state 0
                {
                    sequenceStopwatch.Reset();
                    chkbxGestures.SetItemCheckState(0, CheckState.Unchecked);            // Resets the checkbox of the gestures made
                    chkbxGestures.SetItemCheckState(1, CheckState.Unchecked);            // Resets the checkbox of the gestures made
                    chkbxGestures.SetItemCheckState(2, CheckState.Unchecked);            // Resets the checkbox of the gestures made
                    chkbxGestures.SetItemCheckState(3, CheckState.Unchecked);            // Resets the checkbox of the gestures made
                    chkbxGestures.SetItemCheckState(4, CheckState.Unchecked);            // Resets the checkbox of the gestures made
                    chkbxGestures.SetItemCheckState(5, CheckState.Unchecked);            // Resets the checkbox of the gestures made
                    txtbxGestureSequence.Text = "State 0"; 
                    if (xAccelRaw < GESTURE_THRESHOLD_LOWER)                             // Gesture made in the +X direction
                    {                                                                   
                        chkbxGestures.SetItemCheckState(0, CheckState.Checked);         
                        if (!sequenceStopwatch.IsRunning) sequenceStopwatch.Start();    
                        gestureState = 1;                                               
                    }
                    else if (xAccelRaw > GESTURE_THRESHOLD_UPPER)                        // Gesture made in the -X direction
                    {
                        chkbxGestures.SetItemCheckState(3, CheckState.Checked);          
                        if (!sequenceStopwatch.IsRunning) sequenceStopwatch.Start();     
                        gestureState = 4;
                    }
                    else if (yAccelRaw < GESTURE_THRESHOLD_LOWER)                        // Gesture made in the +Y direction
                    {
                        chkbxGestures.SetItemCheckState(1, CheckState.Checked);          
                        if (!sequenceStopwatch.IsRunning) sequenceStopwatch.Start();     
                        gestureState = 5;
                    }
                    else if (yAccelRaw > GESTURE_THRESHOLD_UPPER)                        // Gesture made in the -Y direction
                    {
                        chkbxGestures.SetItemCheckState(4, CheckState.Checked);         
                        if (!sequenceStopwatch.IsRunning) sequenceStopwatch.Start();    
                        gestureState = 6;
                    }
                    else if (zAccelRaw < GESTURE_THRESHOLD_LOWER + GRAVITY_CALIBRATION_NUM)   // Gesture made in the -Z direction
                    {
                        chkbxGestures.SetItemCheckState(5, CheckState.Checked);          
                        if (!sequenceStopwatch.IsRunning) sequenceStopwatch.Start();     
                        gestureState = 8;
                    }
                    else if (zAccelRaw > GESTURE_THRESHOLD_UPPER + GRAVITY_CALIBRATION_NUM)   // Gesture made in the +Z direction
                    {
                        chkbxGestures.SetItemCheckState(2, CheckState.Checked);          
                        if (!sequenceStopwatch.IsRunning) sequenceStopwatch.Start();     
                        gestureState = 7;
                    }
                }                                                                        
                else if (gestureState == 1)                                              
                {
                    txtbxGestureSequence.Text = "State 1, Simple punch"; 
                    if (yAccelRaw > GESTURE_THRESHOLD_UPPER && sequenceStopwatch.ElapsedMilliseconds > TIME_BEFORE_NEXT_GESTURE)
                    {                                                                    
                        chkbxGestures.SetItemCheckState(1, CheckState.Checked);          
                        gestureState = 2;
                        sequenceStopwatch.Restart();
                    }                                                                    
                    else if (sequenceStopwatch.ElapsedMilliseconds > COMPLETED_GESTURE_TIMEOUT)               
                        gestureState = 0;                                               
                }                                                                       
                else if (gestureState == 2)                                             
                {
                    txtbxGestureSequence.Text = "State 2, +X +Y, Frisbee throw"; 
                    //if (zAccelRaw > GESTURE_THRESHOLD_UPPER && sequenceStopwatch.ElapsedMilliseconds > TIME_BEFORE_NEXT_GESTURE)                                   // 
                    //{                                                                    
                    //    chkbxGestures.SetItemCheckState(2, CheckState.Checked);                                        
                    //    gestureState = 3;
                    //    sequenceStopwatch.Restart();
                    //}                                                                    
                    //else 
                    if (sequenceStopwatch.ElapsedMilliseconds > MULTISTAGE_GESTURE_TIMEOUT)               
                        gestureState = 0;                                                
                }                                                                        
                else if (gestureState == 3)                                              
                {
                    txtbxGestureSequence.Text = "State 3"; 
                    if (sequenceStopwatch.ElapsedMilliseconds > COMPLETED_GESTURE_TIMEOUT)                    
                        gestureState = 0;                                                
                }                                                                        
                else if (gestureState == 4)
                {
                    txtbxGestureSequence.Text = "State 4";
                    if (sequenceStopwatch.ElapsedMilliseconds > COMPLETED_GESTURE_TIMEOUT)                    
                        gestureState = 0;                                                
                }
                else if (gestureState == 5)
                {
                    txtbxGestureSequence.Text = "State 5, +Y Go west, young man";
                    if (sequenceStopwatch.ElapsedMilliseconds > COMPLETED_GESTURE_TIMEOUT)                    
                        gestureState = 0;                                                
                }
                else if (gestureState == 6)
                {
                    txtbxGestureSequence.Text = "State 6, -y";
                    if (sequenceStopwatch.ElapsedMilliseconds > COMPLETED_GESTURE_TIMEOUT)                    
                        gestureState = 0;                                                
                }
                else if (gestureState == 7)
                {
                    txtbxGestureSequence.Text = "State 7, +Z";
                    if (yAccelRaw < GESTURE_THRESHOLD_LOWER && sequenceStopwatch.ElapsedMilliseconds > TIME_BEFORE_NEXT_GESTURE)                        // Gesture made in the +Y direction
                    {
                        chkbxGestures.SetItemCheckState(1, CheckState.Checked);
                        gestureState = 9;
                        sequenceStopwatch.Restart();
                    }
                    else if (sequenceStopwatch.ElapsedMilliseconds > MULTISTAGE_GESTURE_TIMEOUT)                    
                        gestureState = 0;                                                
                }
                else if (gestureState == 8)
                {
                    txtbxGestureSequence.Text = "State 8, -z";
                    if (sequenceStopwatch.ElapsedMilliseconds > COMPLETED_GESTURE_TIMEOUT)                    
                        gestureState = 0;                                                
                }
                else if (gestureState == 9)
                {
                    txtbxGestureSequence.Text = "State 9, +Z +Y";
                    if (yAccelRaw > GESTURE_THRESHOLD_UPPER && sequenceStopwatch.ElapsedMilliseconds > TIME_BEFORE_NEXT_GESTURE)                        // Gesture made in the -Y direction
                    {
                        chkbxGestures.SetItemCheckState(4, CheckState.Checked);
                        gestureState = 10;
                        sequenceStopwatch.Restart();
                    }
                    else if (sequenceStopwatch.ElapsedMilliseconds > COMPLETED_GESTURE_TIMEOUT)
                        gestureState = 0;
                }
                else if (gestureState == 10)
                {
                    txtbxGestureSequence.Text = "State 10, +Z +Y -Y, Wave";
                    if (sequenceStopwatch.ElapsedMilliseconds > COMPLETED_GESTURE_TIMEOUT)
                        gestureState = 0;
                }
            }
            /********************************************* START OF IF STATEMENT FOR STATE MACHINE *********************************************/

            /********************************************* START OF IF STATEMENT FOR READING ACCELEROMETER FOR CLEFAIRY GAME *********************************************/
            if (readGestures && (readGestureSequence < MAX_SEQUENCE) && progressBarTime < MAX_PROGRESS_BAR_TIME)
            {
                if (!clefairyBackgroundIsPlaying && clefairyPressButtonTimeAfter.ElapsedMilliseconds > 1500)
                {
                    clefairyBackground.PlayLooping();
                    clefairyBackgroundIsPlaying = true;
                    clefairyPressButtonTimeAfter.Reset();
                }
                if (yAccelRaw > GESTURE_THRESHOLD_UPPER && !triggerStopwatch.IsRunning)
                {
                    lstbxShowRecordedGestures.Items.Add("Right");
                    sequenceInputted.Add(2);
                    readGestureSequence++;
                    maxReadGestures++;
                    triggerStopwatch.Start();
                }
                else if (yAccelRaw < GESTURE_THRESHOLD_LOWER && !triggerStopwatch.IsRunning)
                {
                    lstbxShowRecordedGestures.Items.Add("Left");
                    sequenceInputted.Add(1);
                    readGestureSequence++;
                    maxReadGestures++;
                    triggerStopwatch.Start();
                }
                else if (zAccelRaw > (GESTURE_THRESHOLD_UPPER + GRAVITY_CALIBRATION_NUM)&& !triggerStopwatch.IsRunning)
                {
                    lstbxShowRecordedGestures.Items.Add("Up");
                    sequenceInputted.Add(3);
                    readGestureSequence++;
                    maxReadGestures++;
                    triggerStopwatch.Start();
                }
                else if (zAccelRaw < (GESTURE_THRESHOLD_LOWER + GRAVITY_CALIBRATION_NUM) && !triggerStopwatch.IsRunning)
                {
                    lstbxShowRecordedGestures.Items.Add("Down");
                    sequenceInputted.Add(0);
                    readGestureSequence++;
                    maxReadGestures++;
                    triggerStopwatch.Start();
                }
                if (triggerStopwatch.ElapsedMilliseconds > 500) triggerStopwatch.Reset();
                progressBarTime++;
                pgrsReadInput.PerformStep();
            }
            else if (readGestures && (!(readGestureSequence < MAX_SEQUENCE) || !(progressBarTime < MAX_PROGRESS_BAR_TIME)))
            {
                readGestures = false;
                while(readGestureSequence < MAX_SEQUENCE)
                {
                    sequenceInputted.Add(4);
                    readGestureSequence++;
                }
                readGestureSequence = 0;
                chkbxSequenceNumber.SetItemCheckState(0, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(1, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(2, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(3, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(4, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(5, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(6, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(7, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(8, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(9, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(10, CheckState.Unchecked);
                chkbxSequenceNumber.SetItemCheckState(11, CheckState.Unchecked);
                tmrDisplayRead.Enabled = true;
                displayInstructionTime.Start();
                clefairyDancingSequence.Play();
                clefairyBackgroundIsPlaying = false;
                txtbxClefairyDirections.Text = "Stop!";
            }
            /********************************************* END OF IF STATEMENT FOR READING ACCELEROMETER FOR CLEFAIRY GAME *********************************************/
        }


        private void Form1_FormClosing(object sender, FormClosingEventArgs e)
        {
            lock (serCOM) serCOM.Close();
        }

        private void serCOM_DataReceived(object sender, System.IO.Ports.SerialDataReceivedEventArgs e)
        {
            lock (serCOM)                                                     // Lock the serial port for mutual exclusion
            {                                                                 
                int newByte;                                                  // Initialize variable for reading bytes
                int bytesToRead = serCOM.BytesToRead;                         // Read from serial port the amount of bytes to read
                bytesToReadQueue.Enqueue(bytesToRead);                        // Puts amount of bytes to read to queue for updating form
                byteSequence = 0;                                             // Set byte sequence to 0 for byte array
                newByte = serCOM.ReadByte();                                  // Read byte
                if (newByte == 255)                                           // Check if byte is start byte
                {
                    while (bytesToRead != 0 && serCOM.IsOpen == true)         
                    {
                        newByte = serCOM.ReadByte();
                        readBytes[byteSequence] = Convert.ToByte(newByte);    
                        bytesToRead = serCOM.BytesToRead;                     
                        byteSequence++;                                                  
                    }
                    outputDataQueue.Enqueue(readBytes);                           // Enter the readBytes array into the concurrent outputDataQueue
                }            
            }
        }

        // This button is responsible for starting the "Clefairy Says" mini-game
        private void btnClefairySays_Click(object sender, EventArgs e)
        {
            if (serCOM.IsOpen)
            {
                if (!isGamePlaying)
                {
                    isGamePlaying = true;
                    clefairySaysClassStarting.Play();
                    Stopwatch displayGestureTime = new Stopwatch();
                    Random gestureGenerated = new Random();

                    txtbxP1Mistakes.Clear();
                    txtbxP2Mistakes.Clear();
                    txtbxP3Mistakes.Clear();
                    txtbxP4Mistakes.Clear();
                    txtbxP1Score.Clear();
                    txtbxP2Score.Clear();
                    txtbxP3Score.Clear();
                    txtbxP4Score.Clear();

                    int i = 0;
                    sequenceGenerated.Clear();
                    sequenceAIP2.Clear();
                    sequenceAIP3.Clear();
                    sequenceAIP4.Clear();
                    sequenceInputted.Clear();
                    pgrsReadInput.Value = 0;
                    lstbxShowGeneratedGestures.Items.Clear();
                    lstbxShowRecordedGestures.Items.Clear();
                    scoreP1 = 0;
                    scoreP2 = 0;
                    scoreP3 = 0;
                    scoreP4 = 0;
                    mistakesP1 = 0;
                    mistakesP2 = 0;
                    mistakesP3 = 0;
                    mistakesP4 = 0;
                    calculateScore.Clear();

                    while (i < MAX_SEQUENCE)
                    {
                        sequenceGenerated.Add(gestureGenerated.Next(4));
                        sequenceAIP2.Add(gestureGenerated.Next(4));
                        sequenceAIP3.Add(gestureGenerated.Next(4));
                        sequenceAIP4.Add(gestureGenerated.Next(4));
                        i++;
                    }

                    currentSequence = 0;
                    chkbxSequenceNumber.SetItemCheckState(0, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(1, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(2, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(3, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(4, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(5, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(6, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(7, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(8, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(9, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(10, CheckState.Unchecked);
                    chkbxSequenceNumber.SetItemCheckState(11, CheckState.Unchecked);
                    maxReadGestures = 0;


                    txtbxClefairyDirections.Text = "3";
                    tmrDisplayInstructions.Enabled = true;
                    displayInstructionTime.Start();
                }
            }
            else
            {
                MessageBox.Show("The game cannot start if serial port is not connected. Please try again.", "ERROR");
            }
        }

        // This timer is responsible for showing the random gesture sequences
        private void tmrDisplayGenerated_Tick(object sender, EventArgs e)
        {
            
            if (currentSequence < MAX_SEQUENCE)
            {
                displayInstructionTime.Stop();
                if (sequenceGenerated.ElementAt(currentSequence) == 0)
                {
                    lstbxShowGeneratedGestures.Items.Add("Down");
                    txtbxClefairyDirections.Text = Convert.ToString(currentSequence +1) + ") Down";
                    chkbxSequenceNumber.SetItemCheckState(currentSequence, CheckState.Checked);
                }
                else if (sequenceGenerated.ElementAt(currentSequence) == 1)
                {
                    lstbxShowGeneratedGestures.Items.Add("Left");
                    txtbxClefairyDirections.Text = Convert.ToString(currentSequence +1) + ") Left";
                    chkbxSequenceNumber.SetItemCheckState(currentSequence, CheckState.Checked);
                }
                else if (sequenceGenerated.ElementAt(currentSequence) == 2)
                {
                    lstbxShowGeneratedGestures.Items.Add("Right");
                    txtbxClefairyDirections.Text = Convert.ToString(currentSequence +1) + ") Right";
                    chkbxSequenceNumber.SetItemCheckState(currentSequence, CheckState.Checked);
                }
                else if (sequenceGenerated.ElementAt(currentSequence) == 3)
                {
                    lstbxShowGeneratedGestures.Items.Add("Up");
                    txtbxClefairyDirections.Text = Convert.ToString(currentSequence +1) + ") Up";
                    chkbxSequenceNumber.SetItemCheckState(currentSequence, CheckState.Checked);
                }
                currentSequence++;
            }
            else
            {
                clefairyPressButton.Play();
                txtbxClefairyDirections.Text = "Move your accelerometer!";
                clefairyPressButtonTimeAfter.Start();
                readGestureSequence = 0;
                progressBarTime = 0;
                readGestures = true;
                tmrDisplayGenerated.Enabled = false;
            }
        }

        // This timer is responsible for displaying the "Clefairy Dance" and determining how many is correct
        private void tmrDisplayRead_Tick(object sender, EventArgs e)
        {
            if (displayInstructionTime.ElapsedMilliseconds < 10600)
            {
                if (displayInstructionTime.ElapsedMilliseconds >= 2000 && displayInstructionTime.ElapsedMilliseconds < 2300)
                {
                    txtbxClefairyDirections.Text = "Ready, set...";
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 3000 && displayInstructionTime.ElapsedMilliseconds < 3300)
                {
                    txtbxClefairyDirections.Clear();
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 3500 && displayInstructionTime.ElapsedMilliseconds < 3800)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(0)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(0)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(0)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(0)];
                    chkbxSequenceNumber.SetItemCheckState(0, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 4100 && displayInstructionTime.ElapsedMilliseconds < 4400)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(1)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(1)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(1)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(1)];
                    chkbxSequenceNumber.SetItemCheckState(1, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 4700 && displayInstructionTime.ElapsedMilliseconds < 5000)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(2)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(2)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(2)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(2)];
                    chkbxSequenceNumber.SetItemCheckState(2, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 5300 && displayInstructionTime.ElapsedMilliseconds < 5600)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(3)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(3)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(3)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(3)];
                    chkbxSequenceNumber.SetItemCheckState(3, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 5900 && displayInstructionTime.ElapsedMilliseconds < 6200)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(4)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(4)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(4)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(4)];
                    chkbxSequenceNumber.SetItemCheckState(4, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 6500 && displayInstructionTime.ElapsedMilliseconds < 6800)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(5)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(5)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(5)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(5)];
                    chkbxSequenceNumber.SetItemCheckState(5, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 7100 && displayInstructionTime.ElapsedMilliseconds < 7400)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(6)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(6)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(6)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(6)];
                    chkbxSequenceNumber.SetItemCheckState(6, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 7700 && displayInstructionTime.ElapsedMilliseconds < 8000)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(7)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(7)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(7)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(7)];
                    chkbxSequenceNumber.SetItemCheckState(7, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 8300 && displayInstructionTime.ElapsedMilliseconds < 8600)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(8)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(8)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(8)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(8)];
                    chkbxSequenceNumber.SetItemCheckState(8, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 8900 && displayInstructionTime.ElapsedMilliseconds < 9200)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(9)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(9)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(9)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(9)];
                    chkbxSequenceNumber.SetItemCheckState(9, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 9500 && displayInstructionTime.ElapsedMilliseconds < 9800)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(10)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(10)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(10)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(10)];
                    chkbxSequenceNumber.SetItemCheckState(10, CheckState.Checked);
                }
                else if (displayInstructionTime.ElapsedMilliseconds >= 10100 && displayInstructionTime.ElapsedMilliseconds < 10400)
                {
                    picClefairyP1.Image = imglstClefairyP1.Images[sequenceInputted.ElementAt(11)];
                    picClefairyP2.Image = imglstClefairyP2.Images[sequenceAIP2.ElementAt(11)];
                    picClefairyP3.Image = imglstClefairyP3.Images[sequenceAIP3.ElementAt(11)];
                    picClefairyP4.Image = imglstClefairyP4.Images[sequenceAIP4.ElementAt(11)];
                    chkbxSequenceNumber.SetItemCheckState(11, CheckState.Checked);
                }
            }
            else
            {
                displayInstructionTime.Reset();
                picClefairyP1.Image = imglstClefairyP1.Images[5];
                picClefairyP2.Image = imglstClefairyP2.Images[5];
                picClefairyP3.Image = imglstClefairyP3.Images[5];
                picClefairyP4.Image = imglstClefairyP4.Images[5];
                for (int i = 0; i < MAX_SEQUENCE; i++)
                {
                    if (sequenceInputted.ElementAt(i) == sequenceGenerated.ElementAt(i)) scoreP1++;
                    else mistakesP1++;
                    if (sequenceAIP2.ElementAt(i) == sequenceGenerated.ElementAt(i)) scoreP2++;
                    else mistakesP2++;
                    if (sequenceAIP3.ElementAt(i) == sequenceGenerated.ElementAt(i)) scoreP3++;
                    else mistakesP3++;
                    if (sequenceAIP4.ElementAt(i) == sequenceGenerated.ElementAt(i)) scoreP4++;
                    else mistakesP4++;
                }
                txtbxP1Score.Text = Convert.ToString(scoreP1);
                txtbxP2Score.Text = Convert.ToString(scoreP2);
                txtbxP3Score.Text = Convert.ToString(scoreP3);
                txtbxP4Score.Text = Convert.ToString(scoreP4);
                txtbxP1Mistakes.Text = Convert.ToString(mistakesP1);
                txtbxP2Mistakes.Text = Convert.ToString(mistakesP2);
                txtbxP3Mistakes.Text = Convert.ToString(mistakesP3);
                txtbxP4Mistakes.Text = Convert.ToString(mistakesP4);
                calculateScore.Add(scoreP1);                                 // Puts P1 score to list to determine winner
                calculateScore.Add(scoreP2);                                 // Puts P2 score to list to determine winner
                calculateScore.Add(scoreP3);                                 // Puts P3 score to list to determine winner
                calculateScore.Add(scoreP4);                                 // Puts P4 score to list to determine winner
                //while (outputDataQueue.TryDequeue(out removedItemInDataQueue)) { }
                clefairyWins.Play();
                txtbxClefairyDirections.Text = "Player " + Convert.ToString(calculateScore.IndexOf(calculateScore.Max())+1) +" wins!";
                isGamePlaying = false;
                tmrDisplayRead.Enabled = false;
            }
        }

        // This timer is responsible for making sure the form is updated if the USB is unplugged
        private void tmrCheckSerialPort_Tick(object sender, EventArgs e)
        {
            if (!serCOM.IsOpen)
            {
                btnConnectDisconnect.Text = "Connect";    // Changes button text to 'connect'
                lstbxSerParam.Items.Clear();              //
                cmbbxCOMPorts.Enabled = true;             // Enables clicking on the combo box for COM ports
                tmrSerRead.Enabled = false;               // Disables the timer for reading concurrent queue from serial port

                while (outputDataQueue.TryDequeue(out removedItemInDataQueue)) { }      // Clears buffer in queue
                foreach (var series in chrtAccelData.Series)                            // Clears the chart
                {
                    series.Points.Clear();
                }
                graphDatapointCount = 0;

                xAxisList.Clear();                        // Clears the list used for average (statistics)
                yAxisList.Clear();                        // Clears the list used for average (statistics)
                zAxisList.Clear();                        // Clears the list used for average (statistics)

                txtXAxis.Clear();                         // Clears txtXAxis box
                txtYAxis.Clear();                         // Clears txtYAxis box
                txtZAxis.Clear();                         // Clears txtZAxis box
                txtbxOrientation.Clear();                 // Clears orientation text box
                txtbxBytesInQueue.Clear();                // Clears bytes in queue text box
                txtbxBytesToRead.Clear();                 // Clears bytes to read text box
                txtbxGestureSequence.Clear();             // Clears gesture sequence text box
                txtXAvg.Clear();                          // Clears average (statistics) text box
                txtYAvg.Clear();                          // Clears average (statistics) text box
                txtZAvg.Clear();                          // Clears average (statistics) text box
            }
        }

        //This timer is responsible for showing the introduction of the Clefairy Says mini-game
        private void tmrDisplayInstructions_Tick(object sender, EventArgs e)
        {
            if (displayInstructionTime.ElapsedMilliseconds < 6000)
            {

                if (displayInstructionTime.ElapsedMilliseconds >= 900 && displayInstructionTime.ElapsedMilliseconds < 1800)
                    txtbxClefairyDirections.Text = "2";
                else if (displayInstructionTime.ElapsedMilliseconds >= 1800 && displayInstructionTime.ElapsedMilliseconds < 2700)
                    txtbxClefairyDirections.Text = "1";
                else if (displayInstructionTime.ElapsedMilliseconds >= 2700 && displayInstructionTime.ElapsedMilliseconds < 3700)
                    txtbxClefairyDirections.Text = "Go";
                else if (displayInstructionTime.ElapsedMilliseconds >= 3700 && displayInstructionTime.ElapsedMilliseconds < 5100)
                    txtbxClefairyDirections.Text = "Listen up!";
                else if (displayInstructionTime.ElapsedMilliseconds >= 5100)
                    txtbxClefairyDirections.Text = "Remember this!";
            }
            else
            {
                displayInstructionTime.Reset();
                tmrDisplayInstructions.Enabled = false;              // Disables the display instruction timer
                tmrDisplayGenerated.Enabled = true;                  // Starts display generated timer
                clefairyBackground.PlayLooping();                    // Loop the background music
            }
        }

        private void txtbxFileName_Click(object sender, EventArgs e)
        {
            
            saveToCSV.Filter = "CSV|*.csv";
            saveToCSV.ShowDialog();
            if (saveToCSV.FileName != "")
            {
                // Saves the Image via a FileStream created by the OpenFile method.
                fileStreamForCSV = (System.IO.FileStream)saveToCSV.OpenFile();
                txtbxFileName.Text = fileStreamForCSV.Name.ToString();
                fileStreamForCSV.Close();
            }
            else
            {
                MessageBox.Show("No file selected. Please try again.", "ERROR");
            }
        }

        private void chkbxWriteToFile_Click(object sender, EventArgs e)
        {
            if (chkbxWriteToFile.CheckState == CheckState.Checked)
            {
                if (saveToCSV.FileName != "")
                {
                    writeToCSV = true;
                }
                else
                {
                    MessageBox.Show("No file has been specified. Please try again.", "ERROR");
                    chkbxWriteToFile.CheckState = CheckState.Unchecked;
                }
            }
            else
            {
                writeToCSV = false;
            }
        }
    }
}
